---
title: The title of your Semesterproject
subtitle: A subtle subtitle
author: Firstname1 Lastname1 and Firstname2 Lastname2
format:
  html:
    code-fold: true
execute:
  warning: false
  message: false
lang: en  # switch to "de" if you write your report in german
bibliography: bibliography.bib
---

```{r preprocessing}
#| code-summary: preprocessing

# Als erstes: Die Dateien sind im FIT Format: wir brauchen das Package FITfileR
if(!requireNamespace("remotes")) {
    install.packages("remotes")
}

remotes::install_github("grimbough/FITfileR")

library(FITfileR)
library(sf)
library(ggplot2)
library(dplyr)
library(readr)
library(tidyverse)
library(leaflet)




# Funktion zum Umrechnen von Semicircles in Grad
convert_to_degrees <- function(semi_circles) {
  semi_circles * (180 / 2^31)
}

# Funktion erstellen fit to sf und coordinaten umwandeln CH
fit2sf <- function(fit_path){
  
  fit_data <- readFitFile(fit_path)
  records <- records(fit_data)
 
  df <- records[[1]]

  if ("position_lat" %in% names(df) && "position_long" %in% names(df)) {
    df <- df %>%
      mutate(
        position_lat = convert_to_degrees(position_lat),
        position_long = convert_to_degrees(position_long),
        fit_file = fit_path
      )

    st_as_sf(df, coords = c("position_long", "position_lat"), crs = 4326)
  } else {
    NULL  # Gibt NULL zurück, wenn keine Koordinaten vorhanden sind
  }
}

# Funktion zum Extrahieren von .fit-Dateien aus .gz-Dateien
extract_fit_from_gz <- function(gz_file, output_dir = "extracted_fit_files") {
  if (!dir.exists(output_dir)) {
    dir.create(output_dir)
  }
  
# Voller Pfad für die Extraktion erstellen
  fit_file_path <- file.path(output_dir, gsub(".gz$", ".fit", basename(gz_file)))
  
# Öffne die .gz-Datei und schreibe den Inhalt in eine .fit-Datei
  con <- gzfile(gz_file, "rb")
  fit_data <- readBin(con, what = raw(), n = 1e6)
  close(con)
  
  writeBin(fit_data, fit_file_path)
  
  return(fit_file_path)
}

# CSV-Datei mit Informationen zu Aktivitäten lesen
activity_info <- read_csv("export/activities.csv")

# Laufaktivitäten finden und ihre Dateinamen extrahieren
running_activities <- activity_info %>%
  filter(`Tipo attività` == "Corsa") %>%
  pull(`Nome del file`)

# Unterordner im Verzeichnis "export/activities" finden
sub_dirs <- list.dirs(path = "export/activities", full.names = TRUE, recursive = TRUE)

# Alle .gz-Dateien in diesen Unterordnern finden
gz_files <- unlist(lapply(sub_dirs, function(dir) {
  list.files(path = dir, pattern = "\\.gz$", full.names = TRUE)
}))

# .fit-Dateien aus jeder .gz-Datei extrahieren
fit_files <- lapply(gz_files, extract_fit_from_gz)

# Filtern der NULL-Dateien und sicherstellen, dass die Pfade Zeichenvektoren sind
fit_files <- unlist(fit_files[!sapply(fit_files, is.null)])

# Dateinamen der vorhandenen .fit-Dateien im Verzeichnis "extracted_fit_files" finden
existing_fit_names <- list.files(path = "extracted_fit_files", pattern = "\\.fit$", full.names = TRUE)

# Vollständige Pfade der Dateien relativ zum Verzeichnis "extracted_fit_files" erstellen
existing_fit_paths <- file.path("extracted_fit_files", basename(existing_fit_names))

# Nur die Dateinamen der .fit-Dateien aus der Liste der vollständigen Pfade extrahieren und Pfad und Erweiterung entfernen
existing_fit_names <- tools::file_path_sans_ext(basename(existing_fit_paths))

# Nur die Dateinamen der Laufaktivitäten extrahieren und Pfad und Erweiterung entfernen
running_activity_names <- tools::file_path_sans_ext(basename(running_activities))

# Nur die .fit-Dateien behalten, die Laufaktivitäten entsprechen
fit_files_to_keep <- existing_fit_paths[existing_fit_names %in% running_activity_names]

# Nicht benötigte .fit-Dateien im Verzeichnis "extracted_fit_files" entfernen
files_to_remove <- setdiff(existing_fit_paths, fit_files_to_keep)

for (fit_file in files_to_remove) {
  print(paste("Löschen der Datei:", fit_file))
  file.remove(fit_file)
}
------------------------------------------------------------------------------------------
#Importare i file in RStudio
# Lista dei file FIT
fit_files <- list.files(path = "extracted_fit_files", pattern = "\\.fit$", full.names = TRUE)

# Leggi tutti i dati FIT e combinali in un unico dataframe
combined_data <- lapply(fit_files, function(file) {
  fit2sf(file)
}) %>%
  bind_rows()

# Visualizza le prime righe del dataframe combinato
head(combined_data)

----------------------------------------------------------------------------------------------------------
#filtrare corse in CH
 Installa e carica i pacchetti necessari
install.packages("rnaturalearth")
install.packages("rnaturalearthdata")
install.packages("sf")
library(rnaturalearth)
library(rnaturalearthdata)
library(sf)
library(dp)

switzerland_boundary <- ne_countries(scale = "medium", country = "Switzerland", returnclass = "sf")

head(combined_data$geometry)
--------------------------------------------------------------------------------------------
library(sf)
library(dplyr)
library(stringr)

# Verifica del sistema di coordinate attuale
current_crs <- st_crs(combined_data)
print(current_crs)

# Assicurati che il CRS di partenza sia definito correttamente (WGS 84 in questo caso)
if (is.na(current_crs)) {
  combined_data <- st_set_crs(combined_data, 4326)  # Assumendo WGS 84
}

# Definisce il sistema di coordinate svizzero (CH1903+ / LV95)
target_crs <- st_crs(2056)

# Converte le coordinate nel sistema di coordinate target
combined_data1 <- st_transform(combined_data, crs = target_crs)


# Visualizza le prime righe dei dati trasformati per verificare
print(head(combined_data1))

# Controlla se le coordinate risultanti sono sensate
coordinate_check <- st_coordinates(combined_data1)
print(coordinate_check)

# Se le coordinate risultanti non sono sensate, potrebbe esserci un problema nella trasformazione o nei dati di partenza
if (any(coordinate_check < 0)) {
  message("Attenzione: sono presenti coordinate negative. Verifica i dati di partenza e la trasformazione.")
}

# Estrai le coordinate come testo e rimuovi il prefisso "POINT"
combined_data1 <- combined_data1 %>%
  mutate(
    geometry_text = st_as_text(geometry),
    geometry_text = gsub("POINT \\(|\\)", "", geometry_text),
    lon = as.numeric(str_split_fixed(geometry_text, " ", 2)[, 1]),
    lat = as.numeric(str_split_fixed(geometry_text, " ", 2)[, 2])
  ) %>%
  select(-geometry_text)

# Visualizza le prime righe per verificare il risultato
print(head(combined_data1))
  
  
 
library(sf)
library(dplyr)
library(stringr)

# Verifica del sistema di coordinate attuale
current_crs <- st_crs(combined_data)
print(current_crs)

# Definisce il sistema di coordinate svizzero (CH1903+ / LV95)
target_crs <- st_crs(2056)

# Converte le coordinate nel sistema di coordinate target
combined_data1 <- st_transform(combined_data, crs = target_crs)

# Estrai le coordinate come testo, rimuovi il prefisso "POINT", e riconverti in geometria
combined_data1 <- combined_data1 %>%
  mutate(
    geometry_text = gsub("POINT \\(|\\)", "", st_as_text(geometry)),  # Rimuove "POINT (" e ")" lasciando solo le coordinate
    geometry = st_as_sfc(paste0("POINT(", geometry_text, ")"))  # Riconverti in geometria
  )

# Visualizza le prime righe per verificare il risultato
print(head(combined_data1))

# Crea un oggetto sf
sf_data <- st_as_sf(combined_data, coords = c("lon", "lat"), crs = 4326)

# Controlla l'output
print(sf_data)























# Wende die Funktion 'fit2sf' auf alle extrahierten FIT-Dateien an und entferne alle eventuellen NULL-Werte.
fit_list <- lapply(fit_files_filtered, fit2sf) %>% 
  Filter(Negate(is.null), .)

# Vereinige alle sf-Objekte zu einem einzigen und zeige sie an.
fit_sf <- do.call(rbind, fit_list)






# Datenrahmen erstellen für alle Aufzeichnungen
coords_list <- lapply(records, function(record) {
  if ("position_lat" %in% names(record) & "position_long" %in% names(record)) {
    lat <- convert_to_degrees(record$position_lat)
    long <- convert_to_degrees(record$position_long)
    data.frame(latitude = lat, longitude = long)
  } else {
    NULL
  }
})

coords_list <- coords_list[!sapply(coords_list, is.null)]


# Konvertieren der Koordinaten in räumliche Objekte und transformieren
coords_lv95_list <- lapply(coords_list, function(coords) {
  coords_sf <- st_as_sf(coords, coords = c("longitude", "latitude"), crs = 4326) # WGS84
  st_transform(coords_sf, crs = 2056) # LV95
})

# Alle Läufe in einen DataFrame zusammenführen
coords_lv95_all <- do.call(rbind, lapply(seq_along(coords_lv95_list), function(i) {
  coords_lv95_list[[i]]$run <- paste("Run", i)
  coords_lv95_list[[i]]
}))

# Plotten der Läufe auf einer Karte
ggplot() +
  geom_sf(data = coords_lv95_all, aes(), size = 1) +
  theme_minimal() +
  labs(title = "erster Lauf",
       x = "E",
       y = "N",
       color = "Lauf")

library("tmap")

tmap_mode("view")

tm_shape(records) + 
  tm_dots()

``` 


## Abstract

## Introduction

@laube2011 investigate how temporal scale affects the calculation of movement parameters (speed, sinuosity and turning angle) of animal trajectories. 

## Material and Methods

## Results

## Discussion

## Appendix

### Wordcount

<!-- after installing the wordcountadding, remove the line "#| eval: false" -->

```{r}
#| eval: false
wordcountaddin::word_count("index.qmd")
```


